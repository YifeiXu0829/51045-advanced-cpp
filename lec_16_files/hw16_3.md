# Can you construct a problem where truncating an infinite range is genuinely better?

```
template <typename Function>
void take_first_n_odds_after_transform(int n, Function F)
{
    auto odds = views::filter([](int x){ return x%2 != 0; });

    copy(views::iota(1)
           | views::transform(F)
           | odds
           | views::take(n), 
         ostream_iterator<int>(std::cout, "\n"));
}

int main()
{
    auto F = [](int i) { return i*(i+1)/2; };
    take_first_n_odds_after_transform(10, F);
}

```

from the above example, if the caller needs to get the first n odd numbers after each transform with caller defined function F, then there is no way to know how many numbers needed to be generated by views::iota at the beginning.
